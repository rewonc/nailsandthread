<!DOCTYPE HTML>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Jasmine Specs for Nails and Thread</title>

  <!-- Jasmine source files -->
  <link rel="shortcut icon" type="image/png" href="lib/jasmine-2.0.0/jasmine_favicon.png">
  <link rel="stylesheet" type="text/css" href="lib/jasmine-2.0.0/jasmine.css">

  <script type="text/javascript" src="lib/jasmine-2.0.0/jasmine.js"></script>
  <script type="text/javascript" src="lib/jasmine-2.0.0/jasmine-html.js"></script>
  <script type="text/javascript" src="lib/jasmine-2.0.0/boot.js"></script>

  <!-- Source  files  -->
  <script type="text/javascript" src="lib/underscore.js"></script>
  <script type="text/javascript" src="lib/jquery.js"></script>

  <script type="text/javascript" src="src/nailsandthread.js"></script>
  
  <script type="text/javascript" src="spec/NTSpec.js"></script>

  <script type="text/javascript">
  'use strict';
  $(function(){
    //These are the canvases on the page
    var source = document.getElementById('source');
    var target = document.getElementById('target')

    //pixelLoader is a promise that will populate pixels when the image loads. Pixels stores what's left of the image; pixelsToRender is a store of what the algo is drawing.
    var pixelLoader = Parser.getRGB(source, 'img/puppyimg.jpg');
    var pixels;
    var pixelsToRender;
    //todo: log starting lines.

    //grid is a (W*H)x(W*H) matrix, and tells us which node is linked to which node. It requires memory equivalent to (WxH)^2, so adjacency lists are better for graphs with many nodes. But this will work for img of size ~50x50.
    var grid = Grid.generate({width: 35, height: 54});
    //Initial settings
    var lines_count = 0;
    var MAX_LINES_DRAWN_PER_THREAD = 1000;
    var LINE_THICKNESS = {value: 64, margin: 64} 
    //max lines: how many total lines should be drawn per color?
    //If we estimate around 7x7 pixels per inch, maybe 4 thin threads would
    //cover each pixel. So each thread is 256/4 or 64 px in intensity.
    //32 should be the cutoff. If the intensity is > 32, you can draw one+ lines.
    //if below 32, draw none.
    //You should probably reduce the nodes to just whats drawable. 
    //If you check levels on pixlr you can see that the majority of the pixels
    //are in the low intensity range.
    //Also need to normalize the levels of the image.
    //how much each line will decrement the RGB pixel values (scale of 0-255)

    //Iterative function
    var drawColor = function(color, count, node, previous){
      if (count === 0) {console.log("line ended at " + MAX_LINES_DRAWN_PER_THREAD);lines_count+= MAX_LINES_DRAWN_PER_THREAD; return;}
      var origin;
      if (node === undefined && previous === undefined){
        origin = Grid.helpers.getRandom(grid, LINE_THICKNESS, color);
      } else {
        origin = node; 
      }
      var result = Grid.findNextPointFarthest(origin, grid, pixels, color, LINE_THICKNESS);
      if (typeof result.next === "number")  {
        Grid.draw(grid, origin, result.next, result.pixelLine, pixels, LINE_THICKNESS, color, pixelsToRender);
        return drawColor(color, count - 1, result.next, result.prev);    
      }
      else {
        //console.log("new line/backtrace required; failure handler needed")
        lines_count += MAX_LINES_DRAWN_PER_THREAD - count;
        return;
      }
      //else if (previous !== undefined)      {return drawColor(color, count); }
      //else                                  {return drawColor(color, count, previous)}
    }

    var drawColorNarrow = function(color, count, node, previous){
      if (count === 0) {console.log("line ended at " + MAX_LINES_DRAWN_PER_THREAD);lines_count+= MAX_LINES_DRAWN_PER_THREAD; return;}
      var origin;
      if (node === undefined && previous === undefined){
        origin = Grid.helpers.getRandom(grid, LINE_THICKNESS, color);
      } else {
        origin = node; 
      }
      var result = Grid.findNextByWalking(origin, grid, pixels, color, LINE_THICKNESS);
      if (typeof result.next === "number")  {
        Grid.draw(grid, origin, result.next, result.pixelLine, pixels, LINE_THICKNESS, color, pixelsToRender);
        return drawColorNarrow(color, count - 1, result.next, result.prev);    
      }
      else {
        //console.log("new line/backtrace required; failure handler needed")
        lines_count += MAX_LINES_DRAWN_PER_THREAD - count;
        return;
      }
      //else if (previous !== undefined)      {return drawColor(color, count); }
      //else                                  {return drawColor(color, count, previous)}
    }
    
    var timeoutFn;
    var iter = function(){
      //Initiate for each thread
      /*if(lines_count < 0){
        drawColor("red", MAX_LINES_DRAWN_PER_THREAD);
        drawColor("green", MAX_LINES_DRAWN_PER_THREAD);
        drawColor("blue", MAX_LINES_DRAWN_PER_THREAD);
      } else{*/
        drawColorNarrow("red", MAX_LINES_DRAWN_PER_THREAD);
        drawColorNarrow("green", MAX_LINES_DRAWN_PER_THREAD);
        drawColorNarrow("blue", MAX_LINES_DRAWN_PER_THREAD);
     // }
      //Render the adjusted image...
      Canvas.putImage(source, pixels);
      $('#count').html(lines_count);
      if (lines_count < 6000) timeoutFn = setTimeout(iter, 10);
    }

    $('#pause').click(function(){
      clearTimeout(timeoutFn);
      console.log(grid);
    });
    $('#restart').click(function(){
      //iter();
      timeoutFn = setTimeout(iter, 10);
    });
    $('#render').click(function(){
      console.log(pixelsToRender);
      Canvas.putImage(target, pixelsToRender);
    });
    //start the iterating functions after the image loads
    pixelLoader.then(function(val){
      pixels = val;
      Grid.storePixels(grid, pixels);
      pixelsToRender = Canvas.newImageData(target, pixels.width, pixels.height, 255);
      console.log(pixels); 
      console.log(grid);
      console.log(pixelsToRender);
      iter();
    });

      
  });

  </script>

</head>

<body>
  <h2>Source canvas. <span id="count">0</span> lines drawn.</h2>
  <canvas id="source"></canvas>

  <p>Drawing canvas:</p>

  <canvas id="target"></canvas>

  <button id="pause">Pause & log object to console</button>
  <button id="restart">Restart</button>
  <button id="render">Render to Canvas</button>
</body>

</html>
