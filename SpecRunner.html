<!DOCTYPE HTML>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Jasmine Specs for Nails and Thread</title>

  <!-- Jasmine source files -->
  <link rel="shortcut icon" type="image/png" href="lib/jasmine-2.0.0/jasmine_favicon.png">
  <link rel="stylesheet" type="text/css" href="lib/jasmine-2.0.0/jasmine.css">

  <script type="text/javascript" src="lib/jasmine-2.0.0/jasmine.js"></script>
  <script type="text/javascript" src="lib/jasmine-2.0.0/jasmine-html.js"></script>
  <script type="text/javascript" src="lib/jasmine-2.0.0/boot.js"></script>

  <!-- Source  files  -->
  <script type="text/javascript" src="lib/underscore.js"></script>
  <script type="text/javascript" src="lib/jquery.js"></script>

  <!--<script type="text/javascript" src="src/ImageDrawer.js"></script>
  <script type="text/javascript" src="src/ImageParser.js"></script>-->
  <script type="text/javascript" src="src/nailsandthread.js"></script>


  <!--<script type="text/javascript" src="spec/ImageParserSpec.js"></script>-->

  <script type="text/javascript">
  'use strict';
  $(function(){
    //These are the canvases on the page
    var source = document.getElementById('source');
    var target = document.getElementById('target')

    //pixelLoader is a promise that will populate pixels when the image loads
    var pixelLoader = Parser.getRGB(source, 'img/man.jpg');
    var pixels;
    //grid is a (W*H)x(W*H) matrix, and tells us which node is linked to which node. It requires memory equivalent to (WxH)^2, so adjacency lists are better for large images.
    var grid = Grid.generate({width: 35, height: 54});
    console.log(grid);
    //Initial settings
    var MAX_LINES_DRAWN_PER_THREAD = 1800;
    var LINE_THICKNESS = 50; //how much each line will decrement the RGB pixel values (scale of 0-255)

    //Iterative function
    var drawColor = function(color, count, node){
      var origin = node || Math.floor(Math.random()*grid.size);
      var result = Grid.findNextPoint(origin, grid, pixels, color, LINE_THICKNESS);
      console.log("origin: " + origin);
      console.log(result);
      //if (result.next)      {return drawColor(color, count - 1, result.next);    }
      //else                  {return drawColor(color, count + 1, result.previous); }
    }
    
    //start the iterating functions after the image loads
    pixelLoader.then(function(val){
      pixels = val;
      //Initiate for each thread
      console.log(pixels); 
      drawColor("red", MAX_LINES_DRAWN_PER_THREAD);
      drawColor("green", MAX_LINES_DRAWN_PER_THREAD);
      drawColor("blue", MAX_LINES_DRAWN_PER_THREAD);

      //Render the grid to the canvas
      Canvas.render(grid, target);
    });
      
  });
 
 /* load image and convert to array */


/* commented out
var imgData=ctx.getImageData(0,0,c.width,c.height);
// invert colors
for (var i=0;i<imgData.data.length;i+=4)
  {
  imgData.data[i]=255-imgData.data[i];
  imgData.data[i+1]=255-imgData.data[i+1];
  imgData.data[i+2]=255-imgData.data[i+2];
  imgData.data[i+3]=255;
  }
ctx.putImageData(imgData,0,0);

  $(function(){
    var ctx = $("#canvas")[0].getContext("2d");
    var img = $("#image")[0];
    ctx.drawImage(img,0,0)

  });
*/

/* commented in
var imgData=ctx.getImageData(0,0,c.width,c.height);
// invert colors
for (var i=0;i<imgData.data.length;i+=4)
  {
  imgData.data[i]=255-imgData.data[i];
  imgData.data[i+1]=255-imgData.data[i+1];
  imgData.data[i+2]=255-imgData.data[i+2];
  imgData.data[i+3]=255;
  }
ctx.putImageData(imgData,0,0);*/

  </script>

</head>

<body>
  <h2>Source canvas:</h2>
  <canvas id="source"></canvas>

  <p>Drawing canvas:</p>

  <canvas id="target"></canvas>

</body>

</html>
